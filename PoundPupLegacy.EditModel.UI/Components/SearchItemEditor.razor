@inherits ViewerBase
@typeparam T where T: class, EditListItem
@inject ISearchService<T> SearchService

    @if (EnableEdit) {
        <input type="text" class="item-search" @bind="@itemSearch" @oninput="OnSetItemSearch" />
        @if (options.Any()) {
            <div class="options">
                @foreach (var elem in options) {
                    <div class="option" @onclick="() => SelectItem(elem.Id)">@elem.Name</div>
                }
            </div>
        }
    }
    @if (Value is not null)
    {
        <div class="name-and-clear-button">
            <div>@Value.Name</div>
            @if (!IsMandatory) {
                <button type="button" @onclick="Clear">Clear</button>
            }
    
        </div>
    }
@code {
    [Parameter]
    public T? Value { get; set; } = default!;

    [Parameter]
    public EventCallback<T?> ValueChanged { get; set; }

    [Parameter]
    [EditorRequired]
    public bool EnableEdit { get; set; } = default!;

    [Parameter]
    [EditorRequired]
    public bool IsMandatory { get; set; } = default!;

    T[] options = Array.Empty<T>();

    string itemSearch { get; set; } = "";

    private async Task OnSetItemSearch(ChangeEventArgs args)
    {
        options = Array.Empty<T>();
        var searchString = args.Value?.ToString() ?? string.Empty;
        if (!string.IsNullOrEmpty(searchString)) {
            options = (await SearchService.GetItems(
                tenantId: Tenant.Id,
                searchString: searchString
            )).ToArray();
        }
        StateHasChanged();
    }
    private async Task SelectItem(int itemId)
    {
        Value = options.First(x => x.Id == itemId);
        options = Array.Empty<T>();
        itemSearch = "";
        await ValueChanged.InvokeAsync(Value);
    }
    private async Task Clear()
    {
        Value = null;
        await ValueChanged.InvokeAsync(Value);
    }
}
