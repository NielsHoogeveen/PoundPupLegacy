@inherits EditorBase
@inject ITopicSearchService topicSearchService

<div class="node-type-group">

    <div class="term-selector">
        <label for="node-type-@NodeTypeTags.TagNodeType.TagLabelName">@NodeTypeTags.TagNodeType.TagLabelName</label>
        <input type="text" name="node-type-@NodeTypeTags.TagNodeType.TagLabelName" class="tag-search" @bind="@topicSearch" @oninput="OnSetTopicSearch" />
    </div>

    @if (termOptions.Any())
    {
        <div class="term-options">
        @foreach (var elem in termOptions)
        {
                <div class="term-option" @onclick="() => SelectTerm(elem.TermId)">@elem.Name</div>
        }
        </div>
    }
    @if (NodeTypeTags.Entries.Any())
    {
        <div class="tag-elements">
        @foreach (var elem in NodeTypeTags.Entries)
        {


            if (!(elem is NodeTerm.ForUpdate existingNodeTerm && existingNodeTerm.NodeTermStatus == NodeTermStatus.Removed)) {
                <div class="tag-element">
                        <span class="tag-element-name">@elem.Name</span>
                    <button type="button" @onclick="() => SetTagToDeleted(elem.TermId)">delete</button>
                </div>
            }
        }
        </div>
    }
</div>

@code {
    [Parameter]
    [EditorRequired]
    public Tags NodeTypeTags { get; set; } = default!;

    List<NodeTerm.ForCreate> termOptions = new();

    string topicSearch { get; set; } = "";

    private void SelectTerm(int termId)
    {
        var tag = termOptions.FirstOrDefault(x => x.TermId == termId);
        if (tag is not null)
        {
            switch (NodeTypeTags.Entries.FirstOrDefault(x => x.TermId == termId)) {
                case NodeTerm.ForUpdate existingNodeTerm:
                    if (existingNodeTerm.NodeTermStatus == NodeTermStatus.Removed) {
                        existingNodeTerm.NodeTermStatus = NodeTermStatus.Existing;
                    }
                    break;
                case null:
                    NodeTypeTags.Match(
                        c => c.EntriesToCreate.Add(tag),
                        u => u.EntriesToUpdate.Add(new NodeTerm.ForUpdate {
                                TermId = tag.TermId,
                                NodeTermStatus = NodeTermStatus.New,
                                Name = tag.Name,
                                NodeTypeId = tag.NodeTypeId,
                                NodeId = NodeId!.Value
                            })
                    );
                    break;
                default:
                    break;
            }
        }
        termOptions.Clear();
        topicSearch = "";
        StateHasChanged();
    }

    private async Task OnSetTopicSearch(ChangeEventArgs args)
    {
        termOptions.Clear();
        var searchString = args.Value?.ToString() ?? string.Empty;
        if (!string.IsNullOrEmpty(searchString))
        {
            termOptions = await topicSearchService.GetTerms(
                tenantId: TenantId, 
                searchString: searchString,
                nodeTypeIds: NodeTypeTags.TagNodeType.NodeTypeIds
            );
        }
        StateHasChanged();
    }

    private void SetTagToDeleted(int termId)
    {

        NodeTypeTags.Match(
            c => {
                var newEntry = c.EntriesToCreate.First(x => x.TermId == termId);
                c.EntriesToCreate.Remove(newEntry);
            },
            u => {
                var updateEntry = u.EntriesToUpdate.First(x => x.TermId == termId);
                switch (updateEntry.NodeTermStatus) {
                    case NodeTermStatus.Existing:
                        updateEntry.NodeTermStatus = NodeTermStatus.Removed;
                        break;
                    case NodeTermStatus.New:
                        u.EntriesToUpdate.Remove(updateEntry);
                        break;
                }
            }
        );
        StateHasChanged();
    }
}
