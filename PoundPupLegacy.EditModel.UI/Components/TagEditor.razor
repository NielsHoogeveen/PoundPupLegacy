@inherits EditorBase
@inject ITopicSearchService topicSearchService

<div class="node-type-group">

    <div class="term-selector">
        <label for="node-type-@NodeTypeTags.TagNodeType.TagLabelName">@NodeTypeTags.TagNodeType.TagLabelName</label>
        <input type="text" name="node-type-@NodeTypeTags.TagNodeType.TagLabelName" class="tag-search" @bind="@topicSearch" @oninput="OnSetTopicSearch" />
    </div>

    @if (termOptions.Any())
    {
        <div class="term-options">
        @foreach (var elem in termOptions)
        {
                <div class="term-option" @onclick="() => SelectTerm(elem.TermId)">@elem.Name</div>
        }
        </div>
    }
    @if (NodeTypeTags.Entries.Any())
    {
        <div class="tag-elements">
        @foreach (var elem in NodeTypeTags.Entries)
        {


            if (!(elem is NodeTerm.ForUpdate existingNodeTerm && existingNodeTerm.HasBeenDeleted)) {
                <div class="tag-element">
                        <span class="tag-element-name">@elem.Name</span>
                    <button type="button" @onclick="() => SetTagToDeleted(elem.TermId)">delete</button>
                </div>
            }
        }
        </div>
    }
</div>

@code {
    [Parameter]
    [EditorRequired]
    public Tags NodeTypeTags { get; set; } = default!;

    List<NodeTerm.ForCreate> termOptions = new();

    string topicSearch { get; set; } = "";

    private void SelectTerm(int termId)
    {
        var tag = termOptions.FirstOrDefault(x => x.TermId == termId);
        if (tag is not null)
        {
            switch (NodeTypeTags.Entries.FirstOrDefault(x => x.TermId == termId)) {
                case NodeTerm.ForUpdate existingNodeTerm:
                    if (existingNodeTerm.HasBeenDeleted) {
                        existingNodeTerm.HasBeenDeleted = false;
                    }
                    break;
                case null:
                    NodeTypeTags.EntriesToCreate.Add(tag);
                    break;
                default:
                    break;
            }
        }
        termOptions.Clear();
        topicSearch = "";
        StateHasChanged();
    }

    private async Task OnSetTopicSearch(ChangeEventArgs args)
    {
        termOptions.Clear();
        var searchString = args.Value?.ToString() ?? string.Empty;
        if (!string.IsNullOrEmpty(searchString))
        {
            termOptions = await topicSearchService.GetTerms(
                tenantId: TenantId, 
                searchString: searchString,
                nodeTypeIds: NodeTypeTags.TagNodeType.NodeTypeIds
            );
        }
        StateHasChanged();
    }

    private void SetTagToDeleted(int termId)
    {
        
        var elem = NodeTypeTags.Entries.FirstOrDefault(x => x.TermId == termId);
        if (elem is not null)
        {
            if (elem is NodeTerm.ForUpdate existingNodeTerm)
            {
                existingNodeTerm.HasBeenDeleted = true;
            }
            else if (elem is NodeTerm.ForCreate newNodeTerm)
            {
                NodeTypeTags.EntriesToCreate.Remove(newNodeTerm);
            }
            StateHasChanged();
        }
    }
}
